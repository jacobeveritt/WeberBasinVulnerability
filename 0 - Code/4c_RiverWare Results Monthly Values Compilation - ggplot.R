# *------------------------------------------------------------------
# | PROGRAM NAME: Data Compilation
# | FILE NAME: RiverWare Results Monthly Data Compilation
# | DATE: 01/25/20
# | CREATED BY:  Jacob Everitt
# *----------------------------------------------------------------
# | PURPOSE:  Compile Data into 1 data.frame and analyze
# |
# |
# |*------------------------------------------------------------------.
# | DATA USED:  Inputs and Outputs
# |   1 - RiverWare Inputs:
# |     A. - Demand
# |     B. - Inflow
# |     C. - Sedimentation
# | 
# |   2 - RiverWare Outputs
# |     A. - Storage
# |     B. - Shortage
# |
# |*------------------------------------------------------------------
# | CONTENTS: Compilation of data 
# |
# | 0 - Create a Trace notation that matches the output from RiverSmart
# |    a. First Trace is Demand
# |    b. 2nd Trace Notation is Inflow
# |    c. Last Trace Notation is Sedimentation
# | 1 - Create individual dataframes for each Input
# |    A. Demand  -- Tot_Demand
# |    B. Inflow  -- Tot_Inflow
# |    C. Sedimentation  -- Tot_Sed
# |
# | 2 - Create individual dataframes for each output
# |    A. Storage -- Tot_Stor
# |    B. Shortage -- Tot_Short
# |    C. 
# *-----------------------------------------------------------------
# | LIST UPDATES FROM ORIGINAL:
# |
# |
# *------------------------------------------------------------------

### Clear any existing data or functions.
rm(list=ls())
library("dplyr", lib.loc="~/R/win-library/3.5")

if (!require(metR)) { 
  install.packages("metR") 
  library(metR) 
}

if (!require(directlabels)) { 
  install.packages("directlabels") 
  library(directlabels) 
}

if (!require(RColorBrewer)) { 
  install.packages("RColorBrewer",repos="http://cran.r-project.org") 
  library(RColorBrewer) # 
}

if (!require(scales)) { 
  install.packages("scales",repos="http://cran.r-project.org") 
  library(scales) # 
}

library("cowplot")  # for plot_grid

#Record the current directory (0 - Code) for later recall
startWD <- getwd()

###Total Storage Compilation#--------------------------------------------------------------------------------#
#Store the current code directory so we can later return to it (0 - Code)
### Load the package or install if not present
if (!require("RColorBrewer")) {
  install.packages("RColorBrewer")
  library(RColorBrewer)
}
library(readr)
#install.packages("reshape")
library(reshape) #For Melt
library(lubridate) #For month
library(plotly) # For Plots
library(data.table)
library(dplyr)

####-----------------------------Trace Notation--------------------------------------------------
# Build names of folders output by RiverSmart
TraceNumber <- 6
TraceNumber1 <-6
TraceNumber2 <-3
Tot_TraceNum <- TraceNumber*TraceNumber1*TraceNumber2

Trace_Notation <-c(1:Tot_TraceNum)
i=1
for(TTTNum in 1:TraceNumber){
  for(TTNum in 1:TraceNumber1){
    for(TNum in 1:TraceNumber2){
      TraceDirectory <- paste0(",Trace",TNum)
      TraceNum1<- paste0(",Trace",TTNum)
      TraceDirectory <- paste0(TraceNum1,TraceDirectory)
      TraceNum2 <- paste0("Trace",TTTNum)
      TraceDirectory <- paste0(TraceNum2,TraceDirectory)
      
      Trace_Notation[i] <-  TraceDirectory
      i=i+1
    }
  }
}

Trace_Notation_Data<- rep(Trace_Notation,359)

#View(Trace_Notation_Data)

##################################  - 1 - Input data ########################################################

  ######## - A -   Compiling Annual Demands  ########

setwd("../1 - Scenario Processing/Annual Service Area Demand Scenarios/Output")
setwd("~/GitHub/WeberBasinVulnerability/WeberBasinVulnerability/1 - Scenario Processing/Annual Service Area Demand Scenarios/Output")

Tot_Annual_Demand <- read.csv("SumMIandAG.csv")
Tot_Demand <- data.frame(c(1:108))

i=1
j=1
while (i<=6) {
  Tot_Demand[j:(j+17),] <- rep(Tot_Annual_Demand[i,2],(18))  
  i=i+1
  j=j+18
}

#View(Tot_Demand)
colnames(Tot_Demand) <- "Demand"
rownames(Tot_Demand) <- Trace_Notation

#Tot_Demand <- data.frame(Tot_Demand)

Tot_Mnthly_Demand<-data.frame(rep(Tot_Demand$Demand,359))
colnames(Tot_Mnthly_Demand) <- "Demand"
#View(Tot_Monthly_Inflow)              

  ######### - B -  Monthly Inflows Data  ##########

# Switch into local directory
  #setwd("~/GitHub/WeberBasinVulnerability/WeberBasinVulnerability/2 - RiverWare Modeling/Scenario")
  setwd(startWD)
  setwd("../2 - RiverWare Modeling/Scenario")

#Input Monthly data from RiverSmart Analysis
Tot_Mnthly_Inflow <-read.csv("Trace1,Trace1,Trace1/Total Inflows.csv")

i=1
for(TTTNum in 1:TraceNumber){
  for(TTNum in 1:TraceNumber1){
    for(TNum in 1:TraceNumber2){
      TraceDirectory <- paste0(",Trace",TNum)
      TraceDirectory <-paste0 (TraceDirectory,"/Total Inflows.csv")
      TraceNum1<- paste0(",Trace",TTNum)
      TraceDirectory <- paste0(TraceNum1,TraceDirectory)
      TraceNum2 <- paste0("Trace",TTTNum)
      TraceDirectory <- paste0(TraceNum2,TraceDirectory)
      
      Location <- TraceDirectory
      Temp_Storage <- read.csv(Location)
      Tot_Mnthly_Inflow[,i] <- Temp_Storage[,5]
      
      colnames(Tot_Mnthly_Inflow)[i] <-  TraceDirectory
      i=i+1
    }
  }
}

Tot_Mnthly_Inflow <- data.frame(Tot_Mnthly_Inflow)
#View(Tot_Mnthly_Inflow)

Months <- rep(c(1:12),31)
Months<- Months[(11:369)]
Tot_Mnthly_Inflow$Months <- Months

#Create Years
Years <- c(0:372)
i=1
j=1
while (j<=31) {
  Years[(i:(i+11))] <- rep((j-1),12)
  i=i+12
  j=j+1
}
Years<- Years[(11:369)]

#Add months and Years column
#Tot_Mnthly_Inflow$Months <-Months
Tot_Mnthly_Inflow$Years <- Years

#Add a Water year - The water year is designated by the calendar year in which it ends, so the 2010 water year (USGS) started on October 1, 2009 and ended on September 30, 2010
Tot_Mnthly_Inflow$WaterYear <- ifelse(Tot_Mnthly_Inflow$Months>= 10,Tot_Mnthly_Inflow$Years + 1, Tot_Mnthly_Inflow$Years)
WaterYear  <-                  ifelse(Tot_Mnthly_Inflow$Months>= 10,Tot_Mnthly_Inflow$Years + 1, Tot_Mnthly_Inflow$Years)

#Transpose Data
Tot_Mnthly_Inflow_Transposed <- t(Tot_Mnthly_Inflow)
Tot_Mnthly_Inflow_Transposed <- data.frame(Tot_Mnthly_Inflow_Transposed)
    #View(Tot_Mnthly_Inflow_Transposed)
#Stack Columns
Tot_Mnthly_Inflow_Stacked <- stack(Tot_Mnthly_Inflow_Transposed[1:108,1:359])
Tot_Mnthly_Inflow <- Tot_Mnthly_Inflow_Stacked$values


######## - C -   Compiling Total Sedimentation  ########

##Total Sedimentation Changes on Reservoir
  #Move back to code directory
  setwd(startWD)
  #Move into the local input directory
  setwd("../3 - Post Processing")
  
  #setwd("~/GitHub/WeberBasinVulnerability/WeberBasinVulnerability/3 - Post Processing")
  

Tot_Sed <- read.csv("Sedimentation.csv")
Tot_Sed <- Tot_Sed[,2]
Tot_Mnthly_Sed <- rep(Tot_Sed,359)


#### Time Columns: Mnths, Years and Water Years #####
Mnths<-c(1:38772)
i=1
j=1
while (i<=359) {
  Mnths[j:(i*108)]<-Months[i]    
i=i+1
j=j+108
  }
#View(Mnths)

Yrs<-c(1:38772)
i=1
j=1
while (i<=359) {
  Yrs[j:(i*108)]<-Years[i]    
  i=i+1
  j=j+108
}
#View(Yrs)

Wtr_Yrs<-c(1:38772)
i=1
j=1
while (i<=359) {
  Wtr_Yrs[j:(i*108)]<-WaterYear[i]    
  i=i+1
  j=j+108
}

##################   Compile Mnthly Input data    ##################################
#Create Data Frame
  Inputs<- data.frame(Tot_Mnthly_Demand)
  Inputs$Inflow <- Tot_Mnthly_Inflow
  Inputs$Sedimentation <- Tot_Mnthly_Sed
  Inputs$Trace_Notation <- Trace_Notation
  Inputs$Month<-Mnths
  Inputs$Years<-Yrs
  Inputs$WaterYear<-Wtr_Yrs
#Number
  Inputs$Number<-c(1:38772)
  Inputs <- data.frame(Inputs)

##################################  - 2 - Output data ########################################################
#Set Local Directory
  setwd(startWD)
  setwd("../2 - RiverWare Modeling/Scenario")
  
  #setwd("~/GitHub/WeberBasinVulnerability/WeberBasinVulnerability/2 - RiverWare Modeling/Scenario")

Tot_Mnthly_Stor <- read.csv("Trace1,Trace1,Trace1/Total Storage_NO EVAP.csv")
Tot_Mnthly_Short <-read.csv("Trace1,Trace1,Trace1/Total Shortages.csv")

#Create TraceFolder Naming lookup for Values with No Evap.
#Move into the local input directory
#setwd("../2 - RiverWare Modeling/Scenario")
# Switch into local directory
#setwd("~/GitHub/WeberBasinVulnerability/WeberBasinVulnerability/2 - RiverWare Modeling/Scenario")

##### Total Storage #####
i=1
for(TTTNum in 1:TraceNumber){
  for(TTNum in 1:TraceNumber1){
    for(TNum in 1:TraceNumber2){
      TraceDirectory <- paste0(",Trace",TNum)
      TraceDirectory <-paste0 (TraceDirectory,"/Total Storage_NO EVAP.csv")
      TraceNum1<- paste0(",Trace",TTNum)
      TraceDirectory <- paste0(TraceNum1,TraceDirectory)
      TraceNum2 <- paste0("Trace",TTTNum)
      TraceDirectory <- paste0(TraceNum2,TraceDirectory)
      
      Location <- TraceDirectory
      Temp_Storage <- read.csv(Location)
      Tot_Mnthly_Stor[,i] <- Temp_Storage[,5]
      
      colnames(Tot_Mnthly_Stor)[i] <-  TraceDirectory
      i=i+1
    }
  }
}
Tot_Mnthly_Stor <- data.frame(Tot_Mnthly_Stor)

#Transpose Data
Tot_Mnthly_Stor_Transposed <- t(Tot_Mnthly_Stor)
Tot_Mnthly_Stor_Transposed <- data.frame(Tot_Mnthly_Stor_Transposed)
#View(Tot_Mnthly_Inflow_Transposed)
#Stack Columns
Tot_Mnthly_Stor_Stacked <- stack(Tot_Mnthly_Stor_Transposed[1:108,1:359])
Tot_Mnthly_Stor <- Tot_Mnthly_Stor_Stacked$values
Tot_Mnthly_Stor <- data.frame(Tot_Mnthly_Stor)

##### Total Shortages #####
i=1
for(TTTNum in 1:TraceNumber){
  for(TTNum in 1:TraceNumber1){
    for(TNum in 1:TraceNumber2){
      TraceDirectory <- paste0(",Trace",TNum)
      TraceDirectory <-paste0 (TraceDirectory,"/Total Shortages.csv")
      TraceNum1<- paste0(",Trace",TTNum)
      TraceDirectory <- paste0(TraceNum1,TraceDirectory)
      TraceNum2 <- paste0("Trace",TTTNum)
      TraceDirectory <- paste0(TraceNum2,TraceDirectory)
      Location <- TraceDirectory
      Temp_Storage <- read.csv(Location)
      Tot_Mnthly_Short[,i] <- Temp_Storage[,5]
      colnames(Tot_Mnthly_Short)[i] <-  TraceDirectory
      i=i+1
    }
  }
}
Tot_Mnthly_Short <- data.frame(Tot_Mnthly_Short)

#Transpose Data
Tot_Mnthly_Short_Transposed <- t(Tot_Mnthly_Short)
Tot_Mnthly_Short_Transposed <- data.frame(Tot_Mnthly_Short_Transposed)
#View(Tot_Mnthly_Inflow_Transposed)
#Stack Columns
Tot_Mnthly_Short_Stacked <- stack(Tot_Mnthly_Short_Transposed[1:108,1:359])
Tot_Mnthly_Short <- Tot_Mnthly_Short_Stacked$values
#Tot_Mnthly_Short <- data.frame(Tot_Mnthly_Short)


########################   Compile Output data   ###############################
Outputs <- Tot_Mnthly_Stor
Outputs$Shortage <- Tot_Mnthly_Short

# Add Trace Notation
#Outputs$Trace_Notation <-Trace_Notation
#Number
Outputs$Number<-c(1:38772)

Outputs<-data.frame(Outputs)

#########################  Merge  ---- Data Dataframe########################
Data <- merge(Inputs,Outputs,by="Number")  
#Data_Monthly <- Data

#########################################################################################################
                      ####### Calculate Annual Inflows -- Calculate Average by Trace#######
#########################################################################################################

#From Monthly Streamflows to Annual Streamflows
Annual_Inflows <-Data %>% 
group_by(WaterYear,Trace_Notation) %>% 
summarise_all(funs(sum(Inflow)))

Avg_Annual_Inflows <- Annual_Inflows %>%
group_by(Trace_Notation) %>%
summarise_all(funs(mean(Inflow)))

Avg_Annual_Inflow<-data.frame(Avg_Annual_Inflows$Inflow)
colnames(Avg_Annual_Inflow)<-"Annual Avg Inflow"
Avg_Annual_Inflow$Trace_Notation <-Trace_Notation
colnames(Avg_Annual_Inflow)[2]<-"Trace_Notation"
#View(Avg_Annual_Inflow)

#Repeat Calculation from monthly shortage to total annual shortage by water year
Annual_Shortage <-Data %>% 
  group_by(WaterYear,Trace_Notation) %>% 
  summarise_all(funs(sum(Shortage)))

Avg_Annual_Shortage <- Annual_Shortage %>%
  group_by(Trace_Notation) %>%
  summarise_all(funs(mean(Shortage)))

Avg_Annual_Shortage<-data.frame(Avg_Annual_Shortage$Shortage)
colnames(Avg_Annual_Shortage)<-"Annual Avg Shortage"
Avg_Annual_Shortage$Trace_Notation <- Trace_Notation
colnames(Avg_Annual_Shortage)[2]<-"Trace_Notation"


#########################################################################################################
####### Calculate Annual Shortage by Water Year #######
#########################################################################################################

#From Monthly Shortages to  Annual Shortages
  #Annual_Shortages <-DataDF %>% 
  # group_by(WaterYear,Trace_Notation) %>% 
  #summarise_all(funs(sum(Shortage)))                   #Issues with intergrating into Data dataframe

  #Annual_Shortages<-data.frame(Annual_Shortages)
  #colnames(Avg_Annual_Inflow)<-"Annual Shortages"
  #Annual_Shortages$Trace_Notation <-Trace_Notation

#########################################################################################################
####### Join Inflow and Shortage Data to DataDF###########
#########################################################################################################

Data <- full_join(Data,Avg_Annual_Inflow,by="Trace_Notation")
Data <- full_join(Data,Avg_Annual_Shortage,by ="Trace_Notation")
#View(Data)

# Reorganize by DER. Calculate storage reliability metrics before filtering.

###########################################################################################################
#################### Reliability  Metric for Storage ########################
###########################################################################################################
#  -- Metrics based on WBWCD - Drought Contigency Plan Drought Levels --  #
# See Table 3-2 : Hot/Dry Projected Drought for Drought Levels
# Moderate Total Basin Storage Drought Level 340K to 380K -- Yellow  ("Less than 380K")
# Severe Total Basin Storage Drought Level 280K to 340K -- Orange    ("Less than 340K")
# Extreme Total Basin Storage Drought Level less than 280K -- Red    ("Less than 280K")

# Define reservoir levels as arrays: Moderate -> Severe -> Extreme
cStoreNames <- c("Moderate", "Severe", "Extreme")
cStorLevels <- c(380000,340000,280000)
cColors <- c("Yellow", "Orange", "Red")
ModerateLevel<- 380000
SevereLevel <- 340000
ExtremeLevel<-280000

#Calculate the number of storage levels
nLevels <- length(cStorLevels)
#Pull out the monthly storage values
    #Storage_Metrics <- data.frame(Data$Tot_Mnthly_Stor)
Storage_Metrics <- data.frame(Data[,c("Month","Tot_Mnthly_Stor")])
#Create more duplicate columns
Storage_Metrics <- cbind(Storage_Metrics, replicate(nLevels-1,Storage_Metrics$Tot_Mnthly_Stor))
#Rename the columns
colnames(Storage_Metrics)[2:(nLevels+1)] <- cStoreNames
#Record the last data column
cLastDataCol <- ncol(Data)

#Loop through columns. In each column convert the storage values to a binary: 1 if greater or equal to target. 0 if below
for (i in 1:nLevels) {
  #Is the storage criteria met?
  Storage_Metrics[,1+i] <- ifelse(Storage_Metrics[,1+i] > cStorLevels[i],1,0)
  
  #Save the result back to the Data datafrom
  Data[,cLastDataCol + i] <- Storage_Metrics[,1+i]
  #Rename the column
  colnames(Data)[cLastDataCol +i] <- cStoreNames[i]
}

###Storage_Rel_Metrics_Moderate <- data.frame(Data$Tot_Mnthly_Stor)
###Storage_Rel_Metrics_Severe <- data.frame(Data$Tot_Mnthly_Stor)
###Storage_Rel_Metrics_Extreme <- data.frame(Data$Tot_Mnthly_Stor)

#Monthly Storage Column Number (MSCN)
 #MSCN <-9

# Moderate
 
 #Reliability_Data_Moderate<-filter(Data,Storage<ModerateLevel)
 
  #i=1
 #while (i<=1080) {
 #  Storage_Rel_Metrics_Moderate[i,] <- ifelse(Data[i,MSCN]>ModerateLevel,1,0)
  # i=i+1
 #}
 
# Severe
 #i=1
 #while (i<=1080) {
  # Storage_Rel_Metrics_Severe[i,] <- ifelse(Data[i,MSCN]>SevereLevel,1,0)
   #i=i+1
 #}
 
# Extreme
 #i=1
 #while (i<=1080) {
  # Storage_Rel_Metrics_Extreme[i,] <- ifelse(Data[i,MSCN]>ExtremeLevel,1,0)
   #i=i+1
#}

#input Metrics into Data Dataframe

 #Data$ModerateStorageR <-Storage_Rel_Metrics_Moderate$Data.Tot_Mnthly_Stor
 #Data$SevereStorageR <- Storage_Rel_Metrics_Severe$Data.Tot_Mnthly_Stor
 #Data$ExtremeStorageR<- Storage_Rel_Metrics_Extreme$Data.Tot_Mnthly_Stor
 
# ## Calculate Reliability
# Stor_Rel_Moderate <- data.frame(1:36)
 #Stor_Rel_Severe <- data.frame(c(1:36))
 #Stor_Rel_Extreme <- data.frame(1:36)

cRelColNames <- paste0("Rel", cStoreNames)

#Calculate the average (fraction) for each combination of traces for each column. This represents
#the reliability
dfStorageReliability <-Data[,c("Trace_Notation","Month",cStoreNames)] %>% 
  filter(Month == 6) %>%  #Filter on the June month because that is when we care about storage at criteria
  group_by(Trace_Notation) %>%
  summarise_all(funs(mean))

#Multiply by 100 to get a percent
dfStorageReliability[,cStoreNames] <- dfStorageReliability[,cStoreNames]*100

# Rename columns
colnames(dfStorageReliability)[3:5] <- c("Mod Reliability", "Sev Reliability","Ext Reliability")

# #Moderate
# Reliability_Data_Moderate <-Data %>% 
 #  group_by(Trace_Notation) %>%
  # summarise(ModPercent = mean(Moderate)*100)
 
 # Severe
 #Reliability_Data_Severe <-Data %>% 
  # group_by(Trace_Notation) %>%
   #summarise(SevPercent = mean(SevereStorageR)*100)
 #View(Reliability_Data_Moderate)

# Extreme
 #Reliability_Data_Extreme <-Data %>% 
  # group_by(Trace_Notation) %>%
   #summarise(ExtPercent = mean(ExtremeStorageR)*100)
 #View(Reliability_Data_Moderate)

##### Join the Reservoir storage reliability back with the big data set
AllData<-right_join(Data,dfStorageReliability,by='Trace_Notation')

## Arrange the Demand and Inflow columns so they plot correctly
AllData <- AllData %>% arrange(Demand, -`Annual Avg Inflow`) ##%>% mutate(Demand=factor(Demand))

#AllData <- AllData %>% arrange(Demand, `Annual Avg Inflow`)
#AllData$DemandFac = with(AllData, reorder(Demand,`Annual Avg Inflow`))

##################################################################################################
###PLOTS###
##################################################################################################

#### DER Attempt in ggPLOT Code to double loop to automate the generation of the matrix contour plot
## for sedimentation rates and storage targets

## FIGURE 8
 
## Rows = Sedimintation levels (0, 10, 30) 
## Columns  = Reservoir Storage Targets (Moderate, Severe, Extreme)
##
## Annotations:
 #
 #    - First column has Sedimentation level, y-axis title, and y-axis ticks
 #    - First row has column header (Storage criteria)
 #    - Final row has x-axis title and ticks

# Change into the plot folder
setwd(startWD)
setwd("../4 - Plots/ggPlot-StorageCriteria")
#setwd("~/GitHub/WeberBasinVulnerability/WeberBasinVulnerability/4 - Plots/ggPlot-StorageCriteria")

# Define the dataframes to populate cell values
 #Storage Targets:
 dfStorageTargets <- data.frame(Name = c("Moderate","Severe","Extreme"),
                                Color = c("Yellow","Orange","Red"),
                                Volume = c(380000,340000,280000),
                                ColumnNum = c(17:19))  #Variable/column number of reliability results in big data frame
 #Calculate a column of different volumes
 dfStorageTargets$VolDiff <- c(-diff(as.matrix(dfStorageTargets$Volume)),280000)
 
 #Grab a lighter shade of color from color brewer
 pReds <- brewer.pal(9,"Reds")
 pOranges <- brewer.pal(9,"Oranges")
 pYelGreen <- brewer.pal(9,"YlGn")
 
 dfStorageTargets$ColorLite <- c(pYelGreen[1],pOranges[3],pReds[3])
 
 #Calculate the subtitle
 dfStorageTargets$Subtitle <- paste0(dfStorageTargets$Name, " (",comma(dfStorageTargets$Volume, digits = 0)," acre-feet)")
 
 cSedValues <- unique(AllData$Sedimentation)
 
 nTargets <- nrow(dfStorageTargets)
 nSeds <- length(cSedValues)
 
 AxisTitles <- c("Demand (1,000 acre-feet/year)","Inflows (1,000 acre-feet/year)")

 
 #Filter AllData down to a single row per inflow/demand/sedimentation combination
 dfScenResults <- AllData %>% filter(Month.x == 1, WaterYear == 1)
 
 #Make a nice Sedimentation column
 dfScenResults$Sed <- paste(percent(dfScenResults$Sedimentation/100), "Sedimentation")
 
 #Label each row with an Inflow scenario monicer
 dfFlowScens <- data.frame(Trace = seq(1:6), StartYear=c(2030, 1940,1930,1610,1520,1570),
                           FlowLabel=c("Hot Dry","Historical\n(1940 to 1970)","","","",""))
 #Create the year to year label
 dfFlowScens$FlowLabel <- ifelse(dfFlowScens$FlowLabel=="",paste0(as.character(dfFlowScens$StartYear)," to ", as.character(dfFlowScens$StartYear+30),sep=""), as.character(dfFlowScens$FlowLabel))
 dfFlowScens$TraceStr <- paste0("Trace",dfFlowScens$Trace)
 
 #Link the Flow scenario name with the trace number
 #Trace numbers are {Trace1,Trace2,Trace3} -- {Demand,Flow,Sedimentation}
 #Split out the trace names. This is a list
 lTraces <- strsplit(dfScenResults$Trace_Notation,",")
 #Convert to a dataframe and transpose
 dfTraces <- as.data.frame(t(as.data.frame(lTraces)))
 #Assign names to the columns
 colnames(dfTraces) <- c("DemTrace","FlowTrace","SedTrace")
 dfTraces$TracesAll <- paste(sep=",",dfTraces$DemTrace,dfTraces$FlowTrace,dfTraces$SedTrace)
 #Joint the flow names
 dfTraces <- left_join(dfTraces,dfFlowScens,by = c("FlowTrace" = "TraceStr"))
 #Join back in
 dfScenResults <- full_join(dfScenResults,dfTraces,by =c("Trace_Notation" = "TracesAll"))
 
 
 #Convert from reliability above target to failures below target
 dfScenResults$`Mod Reliability` <- (100 - dfScenResults$`Mod Reliability`)
 dfScenResults$`Sev Reliability` <-(100 - dfScenResults$`Sev Reliability`)
 dfScenResults$`Ext Reliability` <- (100 - dfScenResults$`Ext Reliability`)
 
 dfPlotData <- dfScenResults
 
 # Add a column to define the point type
 dfPlotData$DataType <- "Model"
 
 #Define a new data frame that represents the historical point
 #Grab the historical inflow
 nHistoricalFlow <- dfPlotData %>% filter(FlowLabel == dfFlowScens$FlowLabel[2]) %>% select(`Annual Avg Inflow`)
 dfHistoricalPoint <- data.frame(Demand = c(549000),
                                 AnnualAvgFlow = nHistoricalFlow$`Annual Avg Inflow`[1] ,
                                 DataType = "Historical")
 
 dfHistoricalPoint$`Mod Reliability` <- 0
                                 
 

 # dfPlotData <- dfScenResults %>% filter(Sedimentation == 0)
 
relBreaks <- c(seq(0,20,by=4),seq(30,100, by=10))
cFlowScens <- sort(unique(dfPlotData$`Annual Avg Inflow`))/1e3
dfFlowScenLabels <- dfPlotData %>% distinct(FlowTrace, `Annual Avg Inflow`,FlowLabel) %>% arrange(`Annual Avg Inflow`)
dfDemScenLabels <- dfPlotData %>% distinct(DemTrace, Demand) %>% arrange(Demand)
dfDemScenLabels$Demand <- dfDemScenLabels$Demand/1e3

  #cDemScens <- sort(unique(dfPlotData$Demand))/1e3
 
#Grab the column names of the data frame
cColNames <- colnames(dfPlotData)
 
colplots <- list() #new empty list

#Loop over the storage target criteria to create column contour plots for each sedimentation levels
for (iTarget in (1:nTargets)) {

  #Grab the column name for the current storage target
  sCurrCol <- paste0("`",cColNames[iTarget+16],"`",sep="")  
     
   #Make three plots (facets) for the different sedimination levels for the storage target
   colplots[[iTarget]] <- 
     ggplot(dfPlotData, aes_string(x="Demand/1e3",y= "`Annual Avg Inflow`/1e3", z = sCurrCol)) +
     #ggplot(dfPlotData, aes_string(x="as.numeric(levels(DemandFac))/1e3",y= "`Annual Avg Inflow`/1e3", z = sCurrCol)) +
     #ggplot(dfPlotData, aes_string(x="reorder(Demand,Demand)/1e3",y= "`Annual Avg Inflow`/1e3", z = sCurrCol)) +
     
          #Fill Color
     metR::geom_contour_fill(breaks = relBreaks ,na.fill = TRUE) +
     #Contour lines
     metR::geom_contour2( colour = "black", binwidth=4, size=0.75, breaks = relBreaks)   +
     #Label contour lines (This is not working very well)
     #metR::geom_text_contour(size=6, check_overlap = TRUE, parse = TRUE) +
     geom_dl(aes(label=..level..),method=list("angled.boxes", cex=1), stat="contour", breaks = relBreaks) +
     
     
     #Overplot points
     #geom_point(size=4) +
     
     #Fill the contours from white to the target color
     scale_fill_gradientn(name = "Reliability",colours = c("White",as.character(dfStorageTargets$Color[iTarget])), na.value = "white") +
     #Create the facets by sedimentation level
     facet_wrap( ~Sed, nrow = nSeds) +
     
     theme_bw() +
     
     guides(fill= "none") +
     scale_size(guide="none") +
     
     labs(x=AxisTitles[1], y=AxisTitles[2]) +
     theme(text = element_text(size=18), 
           legend.position = "none")
   
     print(colplots[[iTarget]])

 }
 
#Combine all the column plots
plot_grid(colplots[[1]], colplots[[2]], colplots[[3]], 
          labels = dfStorageTargets$Subtitle,vjust = 4,  #Position the labels inside the top facet plot
          ncol = 3, nrow = 1)


#Save the plot to file
 ggsave("Fig8-StorageReliability.jpg",width = 12.5,
        height = 7.5, units = "in",
        dpi = 300)

 

 ## FIGURE 7 -- Single plot for Sedmintation Rate == 0, Moderate level.
 ## Overplot the Flow/Demand combo Scenarios as black circles
 ## Add second left- top- axes to annotate flow and demand scenarios
 
 dfPlotData1Frame <- dfPlotData %>% filter(Sedimentation == 0)
 iTarget <- 1
 sCurrCol <- paste0("`",cColNames[iTarget+16],"`",sep="") 

### Original version fo single contour plot 
# pSingleLevel <- ggplot(dfPlotData1Frame, aes_string(x="Demand/1e3",y= "`Annual Avg Inflow`/1e3", z = sCurrCol)) +
# #pSingleLevel <- ggplot(dfPlotData1Frame, aes(x=as.numeric(DemandFac)/1e3,y= `Annual Avg Inflow`/1e3, z = `Mod Reliability`)) +
#   
#      #Fill Color
#    metR::geom_contour_fill(breaks = relBreaks ,na.fill = TRUE) +
#    #Contour lines
#    #metR::geom_contour2( colour = "black", binwidth=4, size=0.75, breaks = relBreaks)   +
#    metR::geom_contour2( colour = "black", size=0.75, breaks = relBreaks)   +
#    #Label contour lines (This is not working very well)
#    #metR::geom_text_contour(aes(label=..level..),size=6, check_overlap = TRUE, parse = TRUE) +
#    geom_dl(aes(label=..level..),method=list("angled.boxes", cex=2), stat="contour", breaks = relBreaks) +
#    
#    #Overplot model scenario points
#    geom_point(size=4, color = "Black", shape = 19) +
#    #Overplot historical point
#    geom_point(data= dfHistoricalPoint, aes(x = Demand/1e3, y = AnnualAvgFlow/1e3), shape = 15, color="Blue", size=6) +
#    # Label the points with reliability. Take out on final.
#    #geom_text(label=sprintf("%.0f",dfPlotData1Frame$`Mod Reliability`), size=5) +
#   
#    #Add secondary x and y axis to label scenarios
#    scale_y_continuous(sec.axis = sec_axis(~. +0, name = "", breaks = dfFlowScenLabels$`Annual Avg Inflow`/1e3, labels = dfFlowScenLabels$FlowLabel)) +
#    scale_x_continuous(sec.axis = sec_axis(~. +0, name = "", breaks = dfDemScenLabels$Demand,  labels = format(dfDemScenLabels$Demand,digits=0))) +
#   
#    
#    #Fill the contours from white to the target color
#    scale_fill_gradientn(name = "Reliability",colours = c("White",as.character(dfStorageTargets$Color[iTarget])), na.value = "white") +
#    #scale_shape_manual(values = c(19,15)) +
#    #scale_color_manual(values = c("Blue","Black")) +
# 
#   #Create the facets by sedimentation level
#    #facet_wrap( ~Sed, nrow = nSeds) +
#    
#    theme_bw() +
#    
#    guides(fill= "none") +
#    guides(shape = guide_legend(title="", order=1)) +
#    scale_size(guide="none") +
#    
#    labs(x=AxisTitles[1], y=AxisTitles[2]) +
#    theme(text = element_text(size=18), 
#          legend.position = "none")
# 
# 
#  
#  print(pSingleLevel)
 
 # #Save the plot to file
 # ggsave("SingleReliability.jpg",width = 7,
 #        height = 5, units = "in",
 #        dpi = 300)
 

 ### Improved version of Figure 7 - single contour plot. Markers for legend.
 
 dfPlotData1Frame$AnnualAvgFlow <- dfPlotData1Frame$`Annual Avg Inflow`
 dfPlotShapes <- dfPlotData1Frame %>% select(Demand, AnnualAvgFlow, DataType, `Mod Reliability`)
 dfPlotShapes$DataType <- as.factor(dfPlotShapes$DataType)

 #Combine the plot and historical data frames into 1
 dfPlotShapes <- rbind(dfHistoricalPoint, dfPlotShapes)
 
 ### Attempt to get shape guides to show
 pSingleTest <- ggplot(dfPlotShapes, aes_string(x="Demand/1e3",y= "`AnnualAvgFlow`/1e3", z = sCurrCol)) +

   #Fill Color
   metR::geom_contour_fill(data=dfPlotData1Frame, aes_string(x="Demand/1e3",y= "`Annual Avg Inflow`/1e3", z = sCurrCol), breaks = relBreaks ,na.fill = TRUE) +
   #Contour lines
   metR::geom_contour2(data=dfPlotData1Frame, aes_string(x="Demand/1e3",y= "`Annual Avg Inflow`/1e3", z = sCurrCol), colour = "black", size=0.75, breaks = relBreaks)   +
   #Label contour lines (This is not working very well)
   geom_dl(data=dfPlotData1Frame, aes(label=..level..),method=list("angled.boxes", cex=2), stat="contour", breaks = relBreaks) +
   
   #Overplot model scenario points
   geom_point(aes(shape=DataType, size=DataType, color = DataType)) +
   #Overplot historical point
   #geom_point(data= dfHistoricalPoint, aes(x = Demand/1e3, y = AnnualAvgFlow/1e3), shape = 15, color="Blue", size=6) +
   # Label the points with reliability. Take out on final.
   #geom_text(label=sprintf("%.0f",dfPlotData1Frame$`Mod Reliability`), size=5) +
   
   #Add secondary x and y axis to label scenarios
   scale_y_continuous(sec.axis = sec_axis(~. +0, name = "", breaks = dfFlowScenLabels$`Annual Avg Inflow`/1e3, labels = dfFlowScenLabels$FlowLabel)) +
   scale_x_continuous(sec.axis = sec_axis(~. +0, name = "", breaks = dfDemScenLabels$Demand,  labels = format(dfDemScenLabels$Demand,digits=0))) +
   
   
   #Fill the contours from white to the target color
   scale_fill_gradientn(name = "Reliability",colours = c("White",as.character(dfStorageTargets$Color[iTarget])), na.value = "white") +
   scale_shape_manual(values = c(15,19)) +  # Square / Circle
   scale_color_manual(values = c("Blue","Black")) +
   scale_size_manual(values = c(6,4)) +
   
   #Create the facets by sedimentation level
   #facet_wrap( ~Sed, nrow = nSeds) +
   
   theme_bw() +
   
   guides(fill= "none") +
   #guides(shape = guide_legend(title="", order=1)) +
   #scale_size(guide="none") +
   
   labs(x=AxisTitles[1], y=AxisTitles[2]) +
   theme(text = element_text(size=18), legend.title=element_blank()) #, 
         #legend.position = "none")
 
 
 print(pSingleTest)
 
 ggsave("Fig7-SingleReliability.jpg",width = 7,
        height = 5, units = "in",
        dpi = 300)
 
 
 ###### ADD TIME SERIES PLOTS #############
 ###
 ### For select runs (combinations of Flow and Demand)
 
 ### Figure 10
 
 #Join the scenario names
 AllData <- full_join(AllData,dfTraces,by =c("Trace_Notation" = "TracesAll"))
 
 #Specify the demand/flow scenario combos we want to plot
 #dfScenarioCombos <- data.frame(FlowScen = c("Trace4","Trace6","Trace1"),
 #                               DemScen = c("Trace5","Trace4","Trace3"))
 
 dfScenarioCombos <- data.frame(FlowScen = c("Trace2","Trace3","Trace1"),  # Historical/558, 1930-1960/711, Hot Dry/840
                                DemScen = c("Trace2","Trace4","Trace6"))
 
 #Filter on the supply, demand scenario combinations
 dfTimePlotData <- inner_join(AllData,dfScenarioCombos,by = c("FlowTrace"= "FlowScen","DemTrace"="DemScen"))
 #Filter out middle Sedimentation trace
 dfTimePlotData <- dfTimePlotData %>% filter(SedTrace != "Trace2")
 #Calculate a year-month-day
 dfTimePlotData$Date <- as.Date(sprintf("%d-%d-%d",dfTimePlotData$Years, dfTimePlotData$Month.x,1))
 #Make a nice Sedimentation column
 dfTimePlotData$Sed <- paste(percent(dfTimePlotData$Sedimentation/100), "Sedimentation")
 #Calculate a Flow-Demand run name
 dfTimePlotData$RunName <- paste(sprintf("%.0f",dfTimePlotData$Demand/1e3),dfTimePlotData$FlowLabel, sep = " / ")
 
 cRunNames <-  unique(dfTimePlotData$RunName)
 
 #Construct the data frame for the storage criteria
 cDateRange <- c(min(dfTimePlotData$Date),max(dfTimePlotData$Date))
 dfStorageCriteria <- do.call("rbind", replicate(2, dfStorageTargets, simplify = FALSE))
 dfStorageCriteria$Date <- c(rep(cDateRange[1],nTargets),rep(cDateRange[2],nTargets))
 
 dfStorageCriteria <- dfStorageCriteria %>% arrange(-Volume)
 
 #Get the colors we will need
 # Light Red
 # Blue scale for lines
 pBlues <- brewer.pal(9,"Blues")
 
 #http://www.sthda.com/english/articles/32-r-graphics-essentials/128-plot-time-series-data-using-ggplot/
 ggplot(dfTimePlotData, aes(x = Date, y = Tot_Mnthly_Stor/1e3)) + 
   #Area plots of storage criteria
   geom_area(data=dfStorageCriteria %>% filter(Name=="Moderate"), aes(x = Date, y= Volume/1e3, color = Name, fill = Name), 
             alpha = 1, position = "identity") +
   geom_area(data=dfStorageCriteria %>% filter(Name=="Severe"), aes(x = Date, y= Volume/1e3, color = Name, fill = Name), 
             alpha = 1, position = "identity") +
   geom_area(data=dfStorageCriteria %>% filter(Name=="Extreme"), aes(x = Date, y= Volume/1e3, color = Name, fill = Name), 
             alpha = 1, position = "identity") +
   #geom_ribbon(data=dfStorageCriteria, aes(ymax = Volume/1e3, ymin=0, fill = Name)) +
   #scale_color_manual(values = dfStorageTargets$Color) +
   scale_fill_manual(values = c(dfStorageTargets$ColorLite[3],dfStorageTargets$ColorLite[1],dfStorageTargets$ColorLite[2]), breaks = c("Moderate","Severe","Extreme")) +
   
   #Line plots of storage series
   geom_line(aes(color = RunName), size = 1) +
   scale_color_manual(values = c(pBlues[3],pBlues[5],pBlues[7], dfStorageTargets$ColorLite[3],dfStorageTargets$ColorLite[1],dfStorageTargets$ColorLite[2]), breaks = cRunNames) +
   facet_wrap(~Sed, nrow = 2) +  # Set nrow to 1 to make the panels side by side
   
   theme_bw() +
   
   guides(fill= guide_legend(title="Storage Target", order=2), color = guide_legend(title="Run (Demand / Flow)", order=1)) +
   scale_size(guide="none") +
   
   labs(x="Model Year", y="Total Storage\n(1,000 acre-feet)") +
   theme(text = element_text(size=18)) 
         #legend.position = "none")
  
 ggsave("Fig10-StorageTimeSeries.jpg",width = 10,
        height = 7, units = "in",
        dpi = 300)
 
 
 ### Alternative version of Figure 10 storage time series - facets are Runs and trace colors are Sedimentation
 
 ggplot(dfTimePlotData, aes(x = Date, y = Tot_Mnthly_Stor/1e3)) + 
   #Area plots of storage criteria
   geom_area(data=dfStorageCriteria %>% filter(Name=="Moderate"), aes(x = Date, y= Volume/1e3, color = Name, fill = Name), 
             alpha = 1, position = "identity") +
   geom_area(data=dfStorageCriteria %>% filter(Name=="Severe"), aes(x = Date, y= Volume/1e3, color = Name, fill = Name), 
             alpha = 1, position = "identity") +
   geom_area(data=dfStorageCriteria %>% filter(Name=="Extreme"), aes(x = Date, y= Volume/1e3, color = Name, fill = Name), 
             alpha = 1, position = "identity") +
   #geom_ribbon(data=dfStorageCriteria, aes(ymax = Volume/1e3, ymin=0, fill = Name)) +
   #scale_color_manual(values = dfStorageTargets$Color) +
   scale_fill_manual(values = c(dfStorageTargets$ColorLite[3],dfStorageTargets$ColorLite[1],dfStorageTargets$ColorLite[2]), breaks = c("Moderate","Severe","Extreme")) +
   
   #Line plots of storage series
   geom_line(aes(color = Sed), size = 1) +
   scale_color_manual(values = c(pBlues[3],pBlues[7], dfStorageTargets$ColorLite[3],dfStorageTargets$ColorLite[1],dfStorageTargets$ColorLite[2]), breaks = cSedValuesForTime) +
   facet_wrap(~RunName, nrow = 3) +  # Set nrow to 1 to make the panels side by side
   
   theme_bw() +
   
   guides(fill= guide_legend(title="Storage Target", order=2), color = guide_legend(title="Run (Demand / Flow)", order=1)) +
   scale_size(guide="none") +
   
   labs(x="Model Year", y="Total Storage\n(1,000 acre-feet)") +
   theme(text = element_text(size=18)) 
 #legend.position = "none")
 
 ggsave("Fig10b-StorageTimeSeries.jpg",width = 10,
        height = 7, units = "in",
        dpi = 300)
 
 
 #### Figure 11 - Show time series of shortage plots for same runs
 
 cSedValuesForTime <- unique(dfTimePlotData$Sed)
 
 ggplot(dfTimePlotData, aes(x = Date, y = Shortage/1e3)) + 

   #Line plots of storage series
   # Sed facets, runs ~ colors
   #geom_line(aes(color = RunName), size = 1) +
   #scale_color_manual(values = c(pBlues[5],pBlues[3],pBlues[7]), breaks = c("1610 to 1640 / 428", "1570 to 1600 / 492","Hot Dry / 544")) +
   #facet_wrap(~Sed, nrow = 2) +  # Set nrow to 1 to make the panels side by side

   #Seds as colors, runs ~ facets
   geom_line(aes(color = Sed), size = 1) +
   scale_color_manual(values = c(pBlues[3],pBlues[7]), breaks = cSedValuesForTime) + #c("0% Sedimentation", "30% Sedimentation")) +
   facet_wrap(~RunName, nrow = 3) +  # Set nrow to 1 to make the panels side by side
   
   
      
   theme_bw() +
   
   #guides(color = guide_legend(title="Run (Flow / Demand)", order=1)) +
   guides(color = guide_legend(title="", order=1)) +
   scale_size(guide="none") +
   
   labs(x="Model Year", y="Shortage\n(1,000 acre-feet)") +
   theme(text = element_text(size=18)) 
 #legend.position = "none")
 
 ggsave("Fig11-ShortageTimeSeries.jpg",width = 10,
        height = 7, units = "in",
        dpi = 300)
 
 
 
#### Figure 12 - Experiment to use Figure 10 but add line thickness at Shortage
 
 ggplot(dfTimePlotData, aes(x = Date, y = Tot_Mnthly_Stor/1e3)) + 
   #Area plots of storage criteria
   geom_area(data=dfStorageCriteria %>% filter(Name=="Moderate"), aes(x = Date, y= Volume/1e3, color = Name, fill = Name), 
             alpha = 1, position = "identity") +
   geom_area(data=dfStorageCriteria %>% filter(Name=="Severe"), aes(x = Date, y= Volume/1e3, color = Name, fill = Name), 
             alpha = 1, position = "identity") +
   geom_area(data=dfStorageCriteria %>% filter(Name=="Extreme"), aes(x = Date, y= Volume/1e3, color = Name, fill = Name), 
             alpha = 1, position = "identity") +
   #geom_ribbon(data=dfStorageCriteria, aes(ymax = Volume/1e3, ymin=0, fill = Name)) +
   #scale_color_manual(values = dfStorageTargets$Color) +
   scale_fill_manual(values = c(dfStorageTargets$ColorLite[3],dfStorageTargets$ColorLite[1],dfStorageTargets$ColorLite[2]), breaks = c("Moderate","Severe","Extreme")) +
   
   #Line plots of storage series
   geom_line(aes(color = RunName, size=Shortage)) +
   scale_color_manual(values = c(pBlues[3],pBlues[5],pBlues[7], dfStorageTargets$ColorLite[3],dfStorageTargets$ColorLite[1],dfStorageTargets$ColorLite[2]), breaks = cRunNames) + # c("428 / 1610 to 1640", "492 / 1570 to 1600","544 / Hot Dry")) +
   facet_wrap(~Sed, nrow = 2) +  # Set nrow to 1 to make the panels side by side
   
   theme_bw() +
   
   guides(fill= guide_legend(title="Storage Target", order=3), 
          color = guide_legend(title="Run (Demand / Flow)", order=1),
          size = guide_legend(title="Shortage (ac-ft per mon.)", order=2)) +
   scale_size(guide="none") +
   
   labs(x="Model Year", y="Total Storage\n(1,000 acre-feet)") +
   theme(text = element_text(size=18)) 
 #legend.position = "none")
 
 ggsave("Fig12-StorageShortageTimeSeries.jpg",width = 10,
        height = 7, units = "in",
        dpi = 300)
 
 
 #Return to original folder
 setwd(startWD)
 
############ End of June 1 code##########
