# *------------------------------------------------------------------
# | PROGRAM NAME: Data Compilation
# | FILE NAME: RiverWare Results Monthly Data Compile - WBWCD Shortage
# | DATE: 01/25/20
# | CREATED BY:  Jacob Everitt
# *----------------------------------------------------------------
# | PURPOSE:  Compile Data into 1 data.frame and analyze
# |   DER -- Show Average annual shortage and maximum annual shortage for each sedimentation level
# |            for Weber Basin Water Conservancy District service areas
# |            These service areas are: 
# |                SA7-Park City
# |                SA12-Ogden Valley
# |                SA10-Gateway
# |                SA15-Slaterville (30,700 of 73,400 acre-feet)
# |
# |*------------------------------------------------------------------.
# | DATA USED:  Inputs and Outputs
# |   1 - RiverWare Inputs:
# |     A. - Demand
# |     B. - Inflow
# |     C. - Sedimentation
# | 
# |   2 - RiverWare Outputs
# |     A. - Storage
# |     B. - Shortage
# |
# |*------------------------------------------------------------------
# | CONTENTS: Compilation of data 
# |
# | 0 - Create a Trace notation that matches the output from RiverSmart
# |    a. First Trace is Demand
# |    b. 2nd Trace Notation is Inflow
# |    c. Last Trace Notation is Sedimentation
# | 1 - Create individual dataframes for each Input
# |    A. Demand  -- Tot_Demand
# |    B. Inflow  -- Tot_Inflow
# |    C. Sedimentation  -- Tot_Sed
# |
# | 2 - Create individual dataframes for each output
# |    A. Storage -- Tot_Stor
# |    B. Shortage -- Tot_Short
# |    C. 
# *-----------------------------------------------------------------
# | LIST UPDATES FROM ORIGINAL:
# |
# |
# *------------------------------------------------------------------

### Clear any existing data or functions.
rm(list=ls())
library("dplyr", lib.loc="~/R/win-library/3.5")

if (!require(metR)) { 
  install.packages("metR") 
  library(metR) 
}

if (!require(directlabels)) { 
  install.packages("directlabels") 
  library(directlabels) 
}

if (!require(RColorBrewer)) { 
  install.packages("RColorBrewer",repos="http://cran.r-project.org") 
  library(RColorBrewer) # 
}

library("cowplot")  # for plot_grid


#Record the current directory (0 - Code) for later recall
startWD <- getwd()

###Total Storage Compilation#--------------------------------------------------------------------------------#
#Store the current code directory so we can later return to it (0 - Code)
### Load the package or install if not present
if (!require("RColorBrewer")) {
  install.packages("RColorBrewer")
  library(RColorBrewer)
}
library(readr)
#install.packages("reshape")
library(reshape) #For Melt
library(lubridate) #For month
library(plotly) # For Plots
library(data.table)
library(dplyr)
library(stringr) #Split string name of service areas

### Definition of Service areas that are part of the Weber Basin Water Conservancy District
dfWBWCDAreas <- data.frame(ServiceArea= c("Park City Diversion", "Slaterville Diversion", "Gateway Canal Diversion","Weber Basin Project Ogden Valley"),
                           FractionServed = c(1,30700/73400,1,1))




####-----------------------------Trace Notation--------------------------------------------------
# Build names of folders output by RiverSmart
TraceNumber <- 6
TraceNumber1 <-6
TraceNumber2 <-3
Tot_TraceNum <- TraceNumber*TraceNumber1*TraceNumber2

Trace_Notation <-c(1:Tot_TraceNum)
i=1
for(TTTNum in 1:TraceNumber){
  for(TTNum in 1:TraceNumber1){
    for(TNum in 1:TraceNumber2){
      TraceDirectory <- paste0(",Trace",TNum)
      TraceNum1<- paste0(",Trace",TTNum)
      TraceDirectory <- paste0(TraceNum1,TraceDirectory)
      TraceNum2 <- paste0("Trace",TTTNum)
      TraceDirectory <- paste0(TraceNum2,TraceDirectory)
      
      Trace_Notation[i] <-  TraceDirectory
      i=i+1
    }
  }
}

Trace_Notation_Data<- rep(Trace_Notation,359)

#View(Trace_Notation_Data)

##################################  - 1 - Input data ########################################################

  ######## - A -   Compiling Annual Demands  ########

setwd("../1 - Scenario Processing/Annual Service Area Demand Scenarios/Output")

Tot_Annual_Demand <- read.csv("SumMIandAG.csv")
Tot_Demand <- data.frame(c(1:108))

i=1
j=1
while (i<=6) {
  Tot_Demand[j:(j+17),] <- rep(Tot_Annual_Demand[i,2],(18))  
  i=i+1
  j=j+18
}

#View(Tot_Demand)
colnames(Tot_Demand) <- "Demand"
rownames(Tot_Demand) <- Trace_Notation

#Tot_Demand <- data.frame(Tot_Demand)

Tot_Mnthly_Demand<-data.frame(rep(Tot_Demand$Demand,359))
colnames(Tot_Mnthly_Demand) <- "Demand"
#View(Tot_Monthly_Inflow)              

  ######### - B -  Monthly Inflows Data  ##########

# Switch into local directory
  #setwd("~/GitHub/WeberBasinVulnerability/WeberBasinVulnerability/2 - RiverWare Modeling/Scenario")
  setwd(startWD)
  setwd("../2 - RiverWare Modeling/Scenario")

#Input Monthly data from RiverSmart Analysis
Tot_Mnthly_Inflow <-read.csv("Trace1,Trace1,Trace1/Total Inflows.csv")

i=1
for(TTTNum in 1:TraceNumber){
  for(TTNum in 1:TraceNumber1){
    for(TNum in 1:TraceNumber2){
      TraceDirectory <- paste0(",Trace",TNum)
      TraceDirectory <-paste0 (TraceDirectory,"/Total Inflows.csv")
      TraceNum1<- paste0(",Trace",TTNum)
      TraceDirectory <- paste0(TraceNum1,TraceDirectory)
      TraceNum2 <- paste0("Trace",TTTNum)
      TraceDirectory <- paste0(TraceNum2,TraceDirectory)
      
      Location <- TraceDirectory
      Temp_Storage <- read.csv(Location)
      Tot_Mnthly_Inflow[,i] <- Temp_Storage[,5]
      
      colnames(Tot_Mnthly_Inflow)[i] <-  TraceDirectory
      i=i+1
    }
  }
}

Tot_Mnthly_Inflow <- data.frame(Tot_Mnthly_Inflow)
#View(Tot_Mnthly_Inflow)

Months <- rep(c(1:12),31)
Months<- Months[(11:369)]
Tot_Mnthly_Inflow$Months <- Months

#Create Years
Years <- c(0:372)
i=1
j=1
while (j<=31) {
  Years[(i:(i+11))] <- rep((j-1),12)
  i=i+12
  j=j+1
}
Years<- Years[(11:369)]

#Add months and Years column
#Tot_Mnthly_Inflow$Months <-Months
Tot_Mnthly_Inflow$Years <- Years

#Add a Water year - The water year is designated by the calendar year in which it ends, so the 2010 water year (USGS) started on October 1, 2009 and ended on September 30, 2010
Tot_Mnthly_Inflow$WaterYear <- ifelse(Tot_Mnthly_Inflow$Months>= 10,Tot_Mnthly_Inflow$Years + 1, Tot_Mnthly_Inflow$Years)
WaterYear<-ifelse(Tot_Mnthly_Inflow$Months>= 10,Tot_Mnthly_Inflow$Years + 1, Tot_Mnthly_Inflow$Years)

#Transpose Data
Tot_Mnthly_Inflow_Transposed <- t(Tot_Mnthly_Inflow)
Tot_Mnthly_Inflow_Transposed <- data.frame(Tot_Mnthly_Inflow_Transposed)
    #View(Tot_Mnthly_Inflow_Transposed)
#Stack Columns
Tot_Mnthly_Inflow_Stacked <- stack(Tot_Mnthly_Inflow_Transposed[1:108,1:359])
Tot_Mnthly_Inflow <- Tot_Mnthly_Inflow_Stacked$values


######## - C -   Compiling Total Sedimentation  ########

##Total Sedimentation Changes on Reservoir
  #Move back to code directory
  setwd(startWD)
  #Move into the local input directory
  setwd("../3 - Post Processing")
  

Tot_Sed <- read.csv("Sedimentation.csv")
Tot_Sed <- Tot_Sed[,2]
Tot_Mnthly_Sed <- rep(Tot_Sed,359)


#### Time Columns: Mnths, Years and Water Years #####
Mnths<-c(1:38772)
i=1
j=1
while (i<=359) {
  Mnths[j:(i*108)]<-Months[i]    
i=i+1
j=j+108
  }
#View(Mnths)

Yrs<-c(1:38772)
i=1
j=1
while (i<=359) {
  Yrs[j:(i*108)]<-Years[i]    
  i=i+1
  j=j+108
}
#View(Yrs)

Wtr_Yrs<-c(1:38772)
i=1
j=1
while (i<=359) {
  Wtr_Yrs[j:(i*108)]<-WaterYear[i]    
  i=i+1
  j=j+108
}

##################   Compile Mnthly Input data    ##################################
#Create Data Frame
  Inputs<- data.frame(Tot_Mnthly_Demand)
  Inputs$Inflow <- Tot_Mnthly_Inflow
  Inputs$Sedimentation <- Tot_Mnthly_Sed
  Inputs$Trace_Notation <- Trace_Notation
  Inputs$Month<-Mnths
  Inputs$Years<-Yrs
  Inputs$WaterYear<-Wtr_Yrs
#Number
  Inputs$Number<-c(1:38772)
  Inputs <- data.frame(Inputs)

##################################  - 2 - Output data ########################################################
#Set Local Directory
  setwd(startWD)
  setwd("../2 - RiverWare Modeling/Scenario")


Tot_Mnthly_Stor <- read.csv("Trace1,Trace1,Trace1/Total Storage_NO EVAP.csv")
Tot_Mnthly_Short <-read.csv("Trace1,Trace1,Trace1/Total Shortages.csv")

#Create TraceFolder Naming lookup for Values with No Evap.
#Move into the local input directory
#setwd("../2 - RiverWare Modeling/Scenario")
# Switch into local directory
#setwd("~/GitHub/WeberBasinVulnerability/WeberBasinVulnerability/2 - RiverWare Modeling/Scenario")

##### Total Storage #####
i=1
for(TTTNum in 1:TraceNumber){
  for(TTNum in 1:TraceNumber1){
    for(TNum in 1:TraceNumber2){
      TraceDirectory <- paste0(",Trace",TNum)
      TraceDirectory <-paste0 (TraceDirectory,"/Total Storage_NO EVAP.csv")
      TraceNum1<- paste0(",Trace",TTNum)
      TraceDirectory <- paste0(TraceNum1,TraceDirectory)
      TraceNum2 <- paste0("Trace",TTTNum)
      TraceDirectory <- paste0(TraceNum2,TraceDirectory)
      
      Location <- TraceDirectory
      Temp_Storage <- read.csv(Location)
      Tot_Mnthly_Stor[,i] <- Temp_Storage[,5]
      
      colnames(Tot_Mnthly_Stor)[i] <-  TraceDirectory
      i=i+1
    }
  }
}
Tot_Mnthly_Stor <- data.frame(Tot_Mnthly_Stor)

#Transpose Data
Tot_Mnthly_Stor_Transposed <- t(Tot_Mnthly_Stor)
Tot_Mnthly_Stor_Transposed <- data.frame(Tot_Mnthly_Stor_Transposed)
#View(Tot_Mnthly_Inflow_Transposed)
#Stack Columns
Tot_Mnthly_Stor_Stacked <- stack(Tot_Mnthly_Stor_Transposed[1:108,1:359])
Tot_Mnthly_Stor <- Tot_Mnthly_Stor_Stacked$values
Tot_Mnthly_Stor <- data.frame(Tot_Mnthly_Stor)

##### Total Shortages #####
i=1
for(TTTNum in 1:TraceNumber){
  for(TTNum in 1:TraceNumber1){
    for(TNum in 1:TraceNumber2){
      TraceDirectory <- paste0(",Trace",TNum)
      TraceDirectory <-paste0 (TraceDirectory,"/Total Shortages.csv")
      TraceNum1<- paste0(",Trace",TTNum)
      TraceDirectory <- paste0(TraceNum1,TraceDirectory)
      TraceNum2 <- paste0("Trace",TTTNum)
      TraceDirectory <- paste0(TraceNum2,TraceDirectory)
      Location <- TraceDirectory
      Temp_Storage <- read.csv(Location)
      Tot_Mnthly_Short[,i] <- Temp_Storage[,5]
      colnames(Tot_Mnthly_Short)[i] <-  TraceDirectory
      i=i+1
    }
  }
}
Tot_Mnthly_Short <- data.frame(Tot_Mnthly_Short)

#Transpose Data
Tot_Mnthly_Short_Transposed <- t(Tot_Mnthly_Short)
Tot_Mnthly_Short_Transposed <- data.frame(Tot_Mnthly_Short_Transposed)
#View(Tot_Mnthly_Inflow_Transposed)
#Stack Columns
Tot_Mnthly_Short_Stacked <- stack(Tot_Mnthly_Short_Transposed[1:108,1:359])
Tot_Mnthly_Short <- Tot_Mnthly_Short_Stacked$values
#Tot_Mnthly_Short <- data.frame(Tot_Mnthly_Short)


########################   Compile Output data   ###############################
Outputs <- Tot_Mnthly_Stor
Outputs$Shortage <- Tot_Mnthly_Short

# Add Trace Notation
#Outputs$Trace_Notation <-Trace_Notation
#Number
Outputs$Number<-c(1:38772)

Outputs<-data.frame(Outputs)


## Read in Shortages for individual service areas

sServiceAreaFile <- 'ServiceAreaShortages'

for(T1 in 1:TraceNumber){
  for(T2 in 1:TraceNumber1){
    for(T3 in 1:TraceNumber2){
      
      #T1 = 1
      #T2 = 1
      #T3 = 1
      
      sTrace <- paste0("Trace",T1,",Trace",T2,",Trace",T3)
      sTraceDirectory <- paste(sTrace,sServiceAreaFile,sep="/")
      
      #TraceDirectory <- paste0(",Trace",TNum)
      #TraceDirectory <-paste0 (TraceDirectory,"/Total Shortages.csv")
      #TraceNum1<- paste0(",Trace",TTNum)
      #TraceDirectory <- paste0(TraceNum1,TraceDirectory)
      #TraceNum2 <- paste0("Trace",TTTNum)
      #TraceDirectory <- paste0(TraceNum2,TraceDirectory)
      #Location <- TraceDirectory
      
      dfCurr <- read.csv(sTraceDirectory)
      
      #Add the trace number to the data frame
      dfCurr$Trace <- sTrace
      
      if ((T1 == 1) && (T2 == 1) && (T3 == 1)) {
        #first trace, do not need to bind
        dfAreaShortage <- dfCurr
      } else {
        # Subsequent trace, need to bind to prior readings
        dfAreaShortage <- rbind(dfAreaShortage, dfCurr)
      }
      #Tot_Mnthly_Short[,i] <- Temp_Storage[,5]
      #colnames(Tot_Mnthly_Short)[i] <-  TraceDirectory
      #i=i+1
      
    }
  }
}

# Clean up the data frame
# A. Convert Timestep to Date, Month, and Water Year
dfAreaShortage$Date <- as.Date(dfAreaShortage$Timestep, "%m-%d-%Y")
dfAreaShortage$Month <- as.numeric(month(dfAreaShortage$Date))
# Convert to Water Year. First year in traces is 2459
nFirstYear <- 2459
dfAreaShortage$WaterYear <- year(dfAreaShortage$Date) - nFirstYear + 1 + ifelse((dfAreaShortage$Month %in% 1:9),-1,0)

# B. Remove Slot from Object.Slot name
cAreas <- strsplit(as.character(dfAreaShortage$Object.Slot),".",1)
cAreas <- as.data.frame(matrix(unlist(cAreas), ncol=2, byrow=TRUE))
dfAreaShortage$ServiceArea <- cAreas$V1

#Get a list of the unique Service Areas
dfServiceAreas <- as.data.frame(as.character(unique(dfAreaShortage$ServiceArea)))
#Clean up the column name
colnames(dfServiceAreas) <- c("ServiceArea")

#Add columns for is a WBWCD service area and fraction service. Pulled from prior data
dfServiceAreas <- left_join(dfServiceAreas,dfWBWCDAreas, by=c("ServiceArea" = "ServiceArea"))
dfServiceAreas$FractionServed <- ifelse(is.na(dfServiceAreas$FractionServed),0,dfServiceAreas$FractionServed)
dfServiceAreas$IsWBWCD <- ifelse(dfServiceAreas$FractionServed > 0,1,0)

# Joint the FractionServed to the ServiceAreas so we can calculate the WBWCD shortage
dfAreaShortage <- left_join(dfAreaShortage,dfServiceAreas, by = c("ServiceArea" = "ServiceArea"))
dfAreaShortage$WBWCDShortage <- dfAreaShortage$Slot.Value*dfAreaShortage$FractionServed

#Sum WBWCD shortage over districts to 

dfWBWCDShortage <- dfAreaShortage %>% group_by(Trace,WaterYear,Month) %>% summarize(WBWCDShortage = sum(WBWCDShortage))

#########################  Merge  ---- Data Dataframe########################
Data <- merge(Inputs,Outputs,by="Number")  

### Join in the WBWCD Shortage
Data <- full_join(Data,dfWBWCDShortage, by = c("Trace_Notation" = "Trace", "WaterYear" = "WaterYear", "Month" = "Month"))

#Data_Monthly <- Data

#########################################################################################################
                      ####### Calculate Annual Inflows -- Calculate Average by Trace#######
#########################################################################################################

#From Monthly Streamflows to Annual Streamflows
Annual_Inflows <-Data %>% 
group_by(WaterYear,Trace_Notation) %>% 
summarise_all(funs(sum(Inflow)))

Avg_Annual_Inflows <- Annual_Inflows %>%
group_by(Trace_Notation) %>%
summarise_all(funs(mean(Inflow)))

Avg_Annual_Inflow<-data.frame(Avg_Annual_Inflows$Inflow)
colnames(Avg_Annual_Inflow)<-"Annual Avg Inflow"
Avg_Annual_Inflow$Trace_Notation <-Trace_Notation
colnames(Avg_Annual_Inflow)[2]<-"Trace_Notation"
#View(Avg_Annual_Inflow)

#Repeat Calculation from monthly shortage to total annual shortage by water year
Annual_Shortage <-Data %>% 
  group_by(WaterYear,Trace_Notation) %>% 
  summarise_all(funs(sum(Shortage)))

Avg_Annual_Shortage <- Annual_Shortage %>%
  group_by(Trace_Notation) %>%
  summarise_all(funs(mean(Shortage)))

Avg_Annual_Shortage<-data.frame(Avg_Annual_Shortage$Shortage)
colnames(Avg_Annual_Shortage)<-"Annual Avg Shortage"
Avg_Annual_Shortage$Trace_Notation <- Trace_Notation
colnames(Avg_Annual_Shortage)[2]<-"Trace_Notation"


#########################################################################################################
####### Calculate Annual Shortage by Water Year #######
#########################################################################################################

#From Monthly Shortages to  Annual Shortages
  #Annual_Shortages <-DataDF %>% 
  # group_by(WaterYear,Trace_Notation) %>% 
  #summarise_all(funs(sum(Shortage)))                   #Issues with intergrating into Data dataframe

  #Annual_Shortages<-data.frame(Annual_Shortages)
  #colnames(Avg_Annual_Inflow)<-"Annual Shortages"
  #Annual_Shortages$Trace_Notation <-Trace_Notation

#########################################################################################################
####### Join Inflow and Shortage Data to DataDF###########
#########################################################################################################

Data <- full_join(Data,Avg_Annual_Inflow,by="Trace_Notation")
Data <- full_join(Data,Avg_Annual_Shortage,by ="Trace_Notation")
#View(Data)

# Reorganize by DER. Calculate storage reliability metrics before filtering.

###########################################################################################################
#################### Reliability  Metric for Storage ########################
###########################################################################################################
#  -- Metrics based on WBWCD - Drought Contigency Plan Drought Levels --  #
# See Table 3-2 : Hot/Dry Projected Drought for Drought Levels
# Moderate Total Basin Storage Drought Level 340K to 380K -- Yellow  ("Less than 380K")
# Severe Total Basin Storage Drought Level 280K to 340K -- Orange    ("Less than 340K")
# Extreme Total Basin Storage Drought Level less than 280K -- Red    ("Less than 280K")

# Define reservoir levels as arrays: Moderate -> Severe -> Extreme
cStoreNames <- c("Moderate", "Severe", "Extreme")
cStorLevels <- c(380000,340000,280000)
cColors <- c("Yellow", "Orange", "Red")
ModerateLevel<- 380000
SevereLevel <- 340000
ExtremeLevel<-280000

#Calculate the number of storage levels
nLevels <- length(cStorLevels)
#Pull out the monthly storage values
    #Storage_Metrics <- data.frame(Data$Tot_Mnthly_Stor)
Storage_Metrics <- data.frame(Data[,c("Month","Tot_Mnthly_Stor")])
#Create more duplicate columns
Storage_Metrics <- cbind(Storage_Metrics, replicate(nLevels-1,Storage_Metrics$Tot_Mnthly_Stor))
#Rename the columns
colnames(Storage_Metrics)[2:(nLevels+1)] <- cStoreNames
#Record the last data column
cLastDataCol <- ncol(Data)

#Loop through columns. In each column convert the storage values to a binary: 1 if greater or equal to target. 0 if below
for (i in 1:nLevels) {
  #Is the storage criteria met?
  Storage_Metrics[,1+i] <- ifelse(Storage_Metrics[,1+i] > cStorLevels[i],1,0)
  
  #Save the result back to the Data datafrom
  Data[,cLastDataCol + i] <- Storage_Metrics[,1+i]
  #Rename the column
  colnames(Data)[cLastDataCol +i] <- cStoreNames[i]
}

###Storage_Rel_Metrics_Moderate <- data.frame(Data$Tot_Mnthly_Stor)
###Storage_Rel_Metrics_Severe <- data.frame(Data$Tot_Mnthly_Stor)
###Storage_Rel_Metrics_Extreme <- data.frame(Data$Tot_Mnthly_Stor)

#Monthly Storage Column Number (MSCN)
 #MSCN <-9

# Moderate
 
 #Reliability_Data_Moderate<-filter(Data,Storage<ModerateLevel)
 
  #i=1
 #while (i<=1080) {
 #  Storage_Rel_Metrics_Moderate[i,] <- ifelse(Data[i,MSCN]>ModerateLevel,1,0)
  # i=i+1
 #}
 
# Severe
 #i=1
 #while (i<=1080) {
  # Storage_Rel_Metrics_Severe[i,] <- ifelse(Data[i,MSCN]>SevereLevel,1,0)
   #i=i+1
 #}
 
# Extreme
 #i=1
 #while (i<=1080) {
  # Storage_Rel_Metrics_Extreme[i,] <- ifelse(Data[i,MSCN]>ExtremeLevel,1,0)
   #i=i+1
#}

#input Metrics into Data Dataframe

 #Data$ModerateStorageR <-Storage_Rel_Metrics_Moderate$Data.Tot_Mnthly_Stor
 #Data$SevereStorageR <- Storage_Rel_Metrics_Severe$Data.Tot_Mnthly_Stor
 #Data$ExtremeStorageR<- Storage_Rel_Metrics_Extreme$Data.Tot_Mnthly_Stor
 
# ## Calculate Reliability
# Stor_Rel_Moderate <- data.frame(1:36)
 #Stor_Rel_Severe <- data.frame(c(1:36))
 #Stor_Rel_Extreme <- data.frame(1:36)

cRelColNames <- paste0("Rel", cStoreNames)

#Calculate the average (fraction) for each combination of traces for each column. This represents
#the reliability
dfStorageReliability <-Data[,c("Trace_Notation","Month",cStoreNames)] %>% 
  filter(Month == 6) %>%  #Filter on the June month because that is when we care about storage at criteria
  group_by(Trace_Notation) %>%
  summarise_all(funs(mean))

#Multiply by 100 to get a percent
dfStorageReliability[,cStoreNames] <- dfStorageReliability[,cStoreNames]*100

# Rename columns
colnames(dfStorageReliability)[3:5] <- c("Mod Reliability", "Sev Reliability","Ext Reliability")

# #Moderate
# Reliability_Data_Moderate <-Data %>% 
 #  group_by(Trace_Notation) %>%
  # summarise(ModPercent = mean(Moderate)*100)
 
 # Severe
 #Reliability_Data_Severe <-Data %>% 
  # group_by(Trace_Notation) %>%
   #summarise(SevPercent = mean(SevereStorageR)*100)
 #View(Reliability_Data_Moderate)

# Extreme
 #Reliability_Data_Extreme <-Data %>% 
  # group_by(Trace_Notation) %>%
   #summarise(ExtPercent = mean(ExtremeStorageR)*100)
 #View(Reliability_Data_Moderate)

##### Join the Reservoir storage reliability back with the big data set
#AllData<-right_join(Data,dfStorageReliability,by='Trace_Notation')
AllData<-left_join(Data,dfStorageReliability,by='Trace_Notation')


##################################################################################################
###PLOTS###
##################################################################################################

#### DER Attempt in ggPLOT Code to show shortage contour plots
## for different sedimentation rates

## Rows = Sedimintation levels (0, 10, 30) 
## Columns  = Different shortage metrics (average annual shortage and maximum annual shortage)
##

#Set Local Directory
setwd(startWD)
setwd("../4 - Plots/ggPlot-StorageCriteria")

#Specify attributes for each shortage metric
cColors <- c("Blue", "Purple")
cShortMetrics <- c("Mean Shortage (acre-feet/year)","Max. Shortage (acre-feet/year)")

cSedValues <- unique(AllData$Sedimentation)

nShortMetrics <- length(cShortMetrics)
nSeds <- length(cSedValues)

AxisTitles <- c("Demand (1,000 acre-feet/year)","Inflows (1,000 acre-feet/year)")
library("scales")

#Calculate Annual Shortage by water year
dfAnnualShortages <-AllData %>% select(Trace_Notation, WaterYear, `Annual Avg Inflow`, Demand, Shortage, Sedimentation, WBWCDShortage) %>%
  group_by(Trace_Notation, WaterYear, `Annual Avg Inflow`, Demand, Sedimentation) %>% 
  summarise(AnnualShort = sum(Shortage), AnnualWBWCDShort = sum(WBWCDShortage))

#Calculate fraction of years with shortages
dfAnnualShortages$ShortYear <- ifelse(dfAnnualShortages$AnnualShort > 100,1,0)
dfAnnualShortages$ShortYearWBWCD <- ifelse(dfAnnualShortages$AnnualWBWCDShort > 100,1,0)

#Calculate average and max shortage for trace and max shorta
dfShortages <- dfAnnualShortages %>% group_by(Trace_Notation,`Annual Avg Inflow`, Demand, Sedimentation) %>% 
  summarise(MeanShort = mean(AnnualShort), MaxShort = max(AnnualShort), NumShortYears = sum(ShortYear),
            MeanWBWCDShort = mean(AnnualWBWCDShort), MaxWBWCDShort = max(AnnualWBWCDShort), NumShortWBWCDYears = sum(ShortYearWBWCD))

#Make a nice Sedimentation column
dfShortages$Sed <- paste(percent(dfShortages$Sedimentation/100), "Sedimentation")


#Label each row with an Inflow scenario monicer
dfFlowScens <- data.frame(Trace = seq(1:6), StartYear=c(2030, 1940,1930,1610,1520,1570),
                          FlowLabel=c("Hot Dry","Historical\n(1940 to 1970)","","","",""),
                          FlowLabel2=c("Hot Dry","Historical (1940 to 1970)","","","",""),
                          FlowLabelAsYear = c("Hot Dry","","","","",""))
#Create the year to year label
dfFlowScens$FlowLabel <- ifelse(dfFlowScens$FlowLabel=="",paste0(as.character(dfFlowScens$StartYear)," to ", as.character(dfFlowScens$StartYear+30),sep=""), as.character(dfFlowScens$FlowLabel))
dfFlowScens$FlowLabel2 <- ifelse(dfFlowScens$FlowLabel2=="",paste0(as.character(dfFlowScens$StartYear)," to ", as.character(dfFlowScens$StartYear+30),sep=""), as.character(dfFlowScens$FlowLabel2))
dfFlowScens$FlowLabelAsYear <- ifelse(dfFlowScens$FlowLabelAsYear=="",paste0(as.character(dfFlowScens$StartYear)," to ", as.character(dfFlowScens$StartYear+30),sep=""), as.character(dfFlowScens$FlowLabelAsYear))

dfFlowScens$TraceStr <- paste0("Trace",dfFlowScens$Trace)

#Link the Flow scenario name with the trace number
#Trace numbers are {Trace1,Trace2,Trace3} -- {Demand,Flow,Sedimentation}
#Split out the trace names. This is a list
lTraces <- strsplit(dfShortages$Trace_Notation,",")
#Convert to a dataframe and transpose
dfTraces <- as.data.frame(t(as.data.frame(lTraces)))
#Assign names to the columns
colnames(dfTraces) <- c("DemTrace","FlowTrace","SedTrace")
dfTraces$TracesAll <- paste(sep=",",dfTraces$DemTrace,dfTraces$FlowTrace,dfTraces$SedTrace)
#Joint the flow names
dfTraces <- left_join(dfTraces,dfFlowScens,by = c("FlowTrace" = "TraceStr"))
#Join back in
dfShortages <- full_join(dfShortages,dfTraces,by =c("Trace_Notation" = "TracesAll"))

#Calculate the ratio of WBWCD shortage to total basin shortage for WBWCD shortage volumes higher than a threshold
nMinShort <- 20000 # Minimum shortage to calculate fraction
dfShortages$FractMeanShortage <- ifelse(dfShortages$MeanWBWCDShort >= nMinShort, round(dfShortages$MeanWBWCDShort / dfShortages$MeanShort * 100,1), 0)
dfShortages$FractMaxShortage <- ifelse(dfShortages$MaxWBWCDShort >= nMinShort, round(dfShortages$MaxWBWCDShort / dfShortages$MaxShort * 100,1), 0)

dfPlotData <- dfShortages

#Constant to control display of shortages (divide acre-feet by xx)
nShortDivide <- 1000

#Construct breaks of contour lines. We want about 10 contour lines
relBreaksAvg <- seq(0,max(dfShortages$MeanWBWCDShort/nShortDivide),by=20)
relBreaksMax <- seq(0,max(dfShortages$MaxWBWCDShort/nShortDivide),by=20)


#Grab the column names of the data frame
cColNames <- colnames(dfPlotData)

colplots <- list() #new empty list



#Define a new data frame that represents the historical point
#Grab the historical inflow
nHistoricalFlow <- dfPlotData %>% filter(FlowLabel == dfFlowScens$FlowLabel[2]) %>% select(`Annual Avg Inflow`)
dfHistoricalPoint <- data.frame(Demand = c(549000),
                                AnnualAvgFlow = nHistoricalFlow$`Annual Avg Inflow`[1] ,
                                DataType = "Historical")
dfHistoricalPoint$`MeanShort` <- 0

dfHistoricalPointMulti <- dfHistoricalPoint
dfHistoricalPointMulti$`MaxShort`<-0
dfHistoricalPointMulti$`NumShortYears`<-0 

#Define the countour box border color - https://stackoverflow.com/questions/24815672/how-can-i-configure-box-color-in-directlabels-draw-rects
my.dl <- list(box.color="red", "draw.rects")
#my.dl <- list(dl.trans(box.color="red"),"draw.rects")

nMetrics <- length(cShortMetrics)

### Figure A - WBWCD mean and max shortages as contour

#Loop over the shortage metrics
for (iMetric in (1:nMetrics)) {
  
  #Grab the column name for the current storage target
  #sCurrCol <- paste0("`",cColNames[iMetric+4],"`","/nShortDivide",sep="")  
  sCurrCol <- paste0(cColNames[iMetric+7],"/nShortDivide",sep="") 
  
  if (iMetric == 1){
    relBreaks <- relBreaksAvg
  } else {
    relBreaks <- relBreaksMax
  }
  
  
  print(sCurrCol)
  
  #Make three plots (facets) for the different sedimination levels for the storage target
  colplots[[iMetric]] <- 
    ggplot(dfPlotData, aes_string(x="Demand/1e3",y= "`Annual Avg Inflow`/1e3", z = sCurrCol)) +

    metR::geom_contour_fill(breaks = relBreaks ,na.fill = TRUE) +
    #Contour lines
    metR::geom_contour2( colour = "black", binwidth=4, size=0.75, breaks = relBreaks)   +
    #Label contour lines (This is not working very well)
    #metR::geom_text_contour(size=6, check_overlap = TRUE, parse = TRUE) +
    #geom_dl(aes(label=..level..),method=list("angled.boxes", cex=1), stat="contour", breaks = relBreaks) +
    #geom_dl(aes(label=..level..),method=list("angled.endpoints", cex=1), stat="contour", breaks = relBreaks) +
    
    # This line is giving an error
    geom_dl(aes(label=..level..), method=list("angled.boxes", cex=1), stat="contour", breaks = relBreaks) +
    
    
    
    
    #Overplot historical point
    
    #geom_point(data= dfHistoricalPointMulti, aes(x = Demand/1e3, y = AnnualAvgFlow/1e3), shape = 15, color="Blue", size=6) +
    geom_point(data= dfHistoricalPointMulti, aes(x = Demand/1e3, y = AnnualAvgFlow/1e3), shape = 15, color="Blue", size=6, inherit.aes = FALSE) +
    
    
    #Fill the contours from white to the target color
    scale_fill_gradient(name = "Reliability",low = "White", high = as.character(cColors[iMetric]), na.value = "white") +
    #scale_fill_gradientn(name = "Reliability",colours = c("White",as.character(cColors[iMetric])), na.value = "white") +
    #Create the facets by sedimentation level
    facet_wrap( ~Sed, nrow = nSeds) +
    
    theme_bw() +
    
    guides(fill= "none") +
    scale_size(guide="none") +
    
    labs(x=AxisTitles[1], y=AxisTitles[2]) +
    theme(text = element_text(size=18), 
          legend.position = "none")
  
  
  #colplots[[iMetric]] <-  direct.label(colplots[[iMetric]], list("far.from.others.borders","calc.boxes", "enlarge.box", "my.dl"))
  
  print(colplots[[iMetric]])
  
}

#Combine all the column plots
plot_grid(colplots[[1]], colplots[[2]], 
          labels = cShortMetrics,vjust = 4,  #Position the labels inside the top facet plot
          ncol = 2, nrow = 1)


#Save the plot to file
ggsave("FigA-ShortageContourWBWCD.jpg", width = 12.5,
       height = 7.5, units = "in",
       dpi = 300)


### Figure B - WBWCD mean and max shortages as a fraction of total Weber Basin shortage

#Construct breaks of contour lines. We want about 10 contour lines
relBreaksAvg <- seq(0,max(dfShortages$FractMeanShortage),by=10)
relBreaksMax <- seq(0,max(dfShortages$FractMaxShortage)+10,by=10)

cShortMetrics <- c("Mean Shortage (%)","Max. Shortage (%)")
#cShortMetrics <- c("Mean Shortage (%)") #,"Max. Shortage (%)")

colplots <- list() #new empty list

nMetrics <- length(cShortMetrics)

ahull.grid <- list("outside.ahull","empty.grid")
chull.grid <- list("outside.chull","empty.grid")

#Loop over the shortage metrics
for (iMetric in (1:nMetrics)) {
  
  #iMetric <- 2
  
  #Grab the column name for the current storage target
  #sCurrCol <- paste0("`",cColNames[iMetric+4],"`","/nShortDivide",sep="")  
  sCurrCol <- paste0(cColNames[iMetric+19]) 

  
  
  if (iMetric == 1){
    relBreaks <- relBreaksAvg
  } else {
    relBreaks <- relBreaksMax
  }
  
  
  print(sCurrCol)
  
  #Make three plots (facets) for the different sedimination levels for the storage target
  colplots[[iMetric]] <- 
    ggplot(dfPlotData, aes_string(x="Demand/1e3",y= "`Annual Avg Inflow`/1e3", z = sCurrCol)) +
    #ggplot(dfPlotData %>% filter(Sedimentation == 10, `Annual Avg Inflow` > 300000, Demand > 300000), aes_string(x="Demand/1e3",y= "`Annual Avg Inflow`/1e3", z = sCurrCol)) +
    
    metR::geom_contour_fill(breaks = relBreaks ,na.fill = TRUE) +
    #Contour lines
    metR::geom_contour2( colour = "black", binwidth=4, size=0.75, breaks = relBreaks)   +
    #Label contour lines (This is not working very well)
    #metR::geom_text_contour(size=6, check_overlap = TRUE, parse = TRUE) +
    #geom_dl(aes(label=..level..),method=list("angled.boxes", cex=1), stat="contour", breaks = relBreaks) +
    #geom_dl(aes(label=..level..),method=list("angled.endpoints", cex=1), stat="contour", breaks = relBreaks) +
    
    #geom_text(aes(label= round(FractMaxShortage,1))) +
    
    
    # This line is giving an error
    geom_dl(aes(label=..level..), method=list("angled.boxes", cex=1), stat="contour", breaks = relBreaks) +
    #geom_dl(aes(label=..level..), method=list("top.pieces", cex=1), stat="contour", breaks = relBreaks) +
    #geom_dl(aes(label=..level..), method=list("chull.grid", cex=1), stat="contour", breaks = relBreaks) +
    
    
       
    #Overplot historical point
    
    #geom_point(data= dfHistoricalPointMulti, aes(x = Demand/1e3, y = AnnualAvgFlow/1e3), shape = 15, color="Blue", size=6) +
    geom_point(data= dfHistoricalPointMulti, aes(x = Demand/1e3, y = AnnualAvgFlow/1e3), shape = 15, color="Blue", size=6, inherit.aes = FALSE) +
    
    
    #Fill the contours from white to the target color
    scale_fill_gradientn(name = "Reliability",colours = c("White",as.character(cColors[iMetric])), na.value = "white") +
    #Create the facets by sedimentation level
    facet_wrap( ~Sed, nrow = nSeds) +
    
    theme_bw() +
    
    guides(fill= "none") +
    scale_size(guide="none") +
    
    labs(x=AxisTitles[1], y=AxisTitles[2]) +
    theme(text = element_text(size=18), 
          legend.position = "none")
  
  
  #colplots[[iMetric]] <-  direct.label(colplots[[iMetric]], list("far.from.others.borders","calc.boxes", "enlarge.box", "my.dl"))
  
  print(colplots[[iMetric]])
  
}

#Combine all the column plots
plot_grid(colplots[[1]], colplots[[2]], 
          labels = cShortMetrics,vjust = 4,  #Position the labels inside the top facet plot
          ncol = 2, nrow = 1)

## Plot as labels on grid for testing
#ggplot(dfPlotData %>% filter(Sedimentation == 10), aes_string(x="Demand/1e3",y= "`Annual Avg Inflow`/1e3")) +
#      geom_text(aes(label= round(FractMaxShortage,1)))
  

#Save the plot to file
ggsave("FigB-ShortageContourWBWCDFractofBasinTotal.jpg", width = 12.5,
       height = 7.5, units = "in",
       dpi = 300)




#####  #### Figure C - Show time series of shortage for WBWCD districts by scenario and compare to basin

## Assemble the monthly time series data
#Specify the demand/flow scenario combos we want to plot
#dfScenarioCombos <- data.frame(FlowScen = c("Trace4","Trace6","Trace1"),
#                               DemScen = c("Trace5","Trace4","Trace3"))

dfScenarioCombos <- data.frame(FlowScen = c("Trace2","Trace3","Trace1"),  # Historical/558, 1930-1960/711, Hot Dry/840
                               DemScen = c("Trace2","Trace4","Trace6"))


#Label each row with an Inflow scenario monicer
dfFlowScens <- data.frame(Trace = seq(1:6), StartYear=c(2030, 1940,1930,1610,1520,1570),
                          FlowLabel=c("Hot Dry","Historical\n(1940 to 1970)","","","",""),
                          FlowLabel2=c("Hot Dry","Historical (1940 to 1970)","","","",""),
                          FlowLabelAsYear = c("Hot Dry","","","","",""))
#Create the year to year label
dfFlowScens$FlowLabel <- ifelse(dfFlowScens$FlowLabel=="",paste0(as.character(dfFlowScens$StartYear)," to ", as.character(dfFlowScens$StartYear+30),sep=""), as.character(dfFlowScens$FlowLabel))
dfFlowScens$FlowLabel2 <- ifelse(dfFlowScens$FlowLabel2=="",paste0(as.character(dfFlowScens$StartYear)," to ", as.character(dfFlowScens$StartYear+30),sep=""), as.character(dfFlowScens$FlowLabel2))
dfFlowScens$FlowLabelAsYear <- ifelse(dfFlowScens$FlowLabelAsYear=="",paste0(as.character(dfFlowScens$StartYear)," to ", as.character(dfFlowScens$StartYear+30),sep=""), as.character(dfFlowScens$FlowLabelAsYear))

dfFlowScens$TraceStr <- paste0("Trace",dfFlowScens$Trace)


#Break out the trace numbers so we can link the Flow scenario name with the trace number
#Trace numbers are {Trace1,Trace2,Trace3} -- {Demand,Flow,Sedimentation}
#Split out the trace names. This is a list
lTraces <- strsplit(unique(AllData$Trace_Notation),",")
#Convert to a dataframe and transpose
dfTraces <- as.data.frame(t(as.data.frame(lTraces)))
#Assign names to the columns
colnames(dfTraces) <- c("DemTrace","FlowTrace","SedTrace")
dfTraces$TracesAll <- paste(sep=",",dfTraces$DemTrace,dfTraces$FlowTrace,dfTraces$SedTrace)
#Joint the flow names
dfTraces <- left_join(dfTraces,dfFlowScens,by = c("FlowTrace" = "TraceStr"))
#Join back in
AllData <- left_join(AllData,dfTraces,by =c("Trace_Notation" = "TracesAll"))


#Filter on the supply, demand scenario combinations
dfTimePlotData <- inner_join(AllData,dfScenarioCombos,by = c("FlowTrace"= "FlowScen","DemTrace"="DemScen"))
#Filter out middle Sedimentation trace
#dfTimePlotData <- dfTimePlotData %>% filter(SedTrace != "Trace2")
#Calculate a year-month-day
dfTimePlotData$Date <- as.Date(sprintf("%d-%d-%d",dfTimePlotData$Years, dfTimePlotData$Month.x,1))
#Make a nice Sedimentation column
dfTimePlotData$Sed <- paste(percent(dfTimePlotData$Sedimentation/100), "Sedimentation")
#Calculate a Flow-Demand run name
dfTimePlotData$RunName <- paste(sprintf("%.0f",dfTimePlotData$Demand/1e3),dfTimePlotData$FlowLabel, sep = " / ")

cRunNames <-  unique(dfTimePlotData$RunName)
cSedValuesForTime <- unique(dfTimePlotData$Sed)

#Construct the data frame for the storage criteria
cDateRange <- c(min(dfTimePlotData$Date),max(dfTimePlotData$Date))

# Blue scale for lines
pBlues <- brewer.pal(9,"Blues")
pReds <- brewer.pal(9,"Reds")



cTimePlotDataColNames <- colnames(dfTimePlotData)
dfTimePlotDataMelt <- melt(dfTimePlotData, 
                           id.vars = cTimePlotDataColNames[c(2:9,12:31)],
                            measure.vars = cTimePlotDataColNames[c(10,11)])
#Create the legend label - combine the melt variable and sedimentation rate
dfTimePlotDataMelt$LegendLabel <- paste(ifelse(dfTimePlotDataMelt$variable == "Shortage","Basin","WBWCD"), dfTimePlotDataMelt$Sed, sep=": ")

#Grab the labels
cLegendLabels <- unique(dfTimePlotDataMelt$LegendLabel)
#Reorder so Sedimentation rate in descending
cLegendLabels <- cLegendLabels[c(3,2,1,6,5,4)]

ggplot(dfTimePlotDataMelt, aes(x = Date, y=value/1000)) + 
  
  #Seds as colors, runs ~ facets
  geom_line(aes(color=LegendLabel), size = 1) +
  scale_color_manual(values = c(pBlues[7],pBlues[5], pBlues[3],pReds[7],pReds[5],pReds[3]), breaks = cLegendLabels) + #, breaks = rep(cSedValuesForTime,2)) + #c("0% Sedimentation", "30% Sedimentation")) +
  facet_wrap(~RunName, nrow = 3) +  # Set nrow to 1 to make the panels side by side

  theme_bw() +
  
  #guides(color = guide_legend(title="Run (Flow / Demand)", order=1)) +
  guides(color = guide_legend(title="", order=1)) +
  scale_size(guide="none") +
  
  labs(x="Model Year", y="Shortage\n(1,000 acre-feet)") +
  theme(text = element_text(size=18)) 
#legend.position = "none")

ggsave("FigC-WBWCDShortageTimeSeries.jpg",width = 10,
       height = 7, units = "in",
       dpi = 300)



############ End of June 1 code##########
setwd(startWD)



